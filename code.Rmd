---
title: "aryl_hydrocarbon"
author: "Isabella Hofstede"
date: "2/10/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


##loading data 
```{r}
my_data <- read.table('./GSE47944_ps_tt_gel_raw.txt', header = TRUE, row.names = 1)
```

##summary
```{r}
summary(my_data)
#de data sample naamgeving is opgebouwd uit samplenaam_patientnummer. Dus het getal op het eind geeft aan bij welke patient het sample hoort
```


##Data preperation
```{r}
# 64 sick samples
sick_data <- my_data[1:64]
#20 healthy samples
healthy_data <- my_data[65: 84]

library(GEOquery)
classification <- getGEO(filename="GSE47944_series_matrix.txt")
phenodata <- classification@phenoData@data
```

##Boxplot Analyses
```{r}
boxplot(log2(my_data + 1), data=my_data, xlab="samples", ylab="log2(counts)", 
    main="Gene counts of healthy and sick patients", las=2, par(cex.axis=0.45))
boxplot(log2(sick_data + 1), data=my_data, xlab="samples", ylab="log2(counts)", 
    main="gene counts of sick patients", col="red", las=2)
boxplot(log2(healthy_data + 1), data=my_data, xlab="samples", ylab="log2(counts)", 
    main="gene counts of healthy patients", col="blue", las=2)
```
##density plot analysis 
```{r}
## The affy library has a density plotting function
library(affy)

## Create a list of 4 colors to use which are the same used throughout this chapter 
library(scales)
myColors <- hue_pal()(4)
```

##density plot of all sick patients
```{r}
## Plot the log2-transformed data with a 0.1 pseudocount of the whole dataset
plotDensity(log2(my_data + 0.1), col=rep(myColors, each=3),
            lty=c(1:ncol(my_data)), xlab='Log2(count)',
            main='Expression Distribution of all patients')

## Add a legend and vertical line
legend('topright', names(my_data), lty=c(1:ncol(my_data)),
       col=rep(myColors, each=3))
abline(v=-1.5, lwd=1, col='red', lty=2)

## Plot the log2-transformed data with a 0.1 pseudocount of the sick patients
plotDensity(log2(sick_data + 0.1), col=rep(myColors, each=3),
            lty=c(1:ncol(sick_data)), xlab='Log2(count)',
            main='Expression Distribution of sick patients')

## Add a legend and vertical line
legend('topright', names(sick_data), lty=c(1:ncol(my_data)),
       col=rep(myColors, each=3))
abline(v=-1.5, lwd=1, col='red', lty=2)

## Plot the log2-transformed data with a 0.1 pseudocount of healthy patients
plotDensity(log2(healthy_data + 0.1), col=rep(myColors, each=3),
            lty=c(1:ncol(healthy_data)), xlab='Log2(count)',
            main='Expression Distribution of healthy patients')

## Add a legend and vertical line
legend('topright', names(healthy_data), lty=c(1:ncol(my_data)),
       col=rep(myColors, each=3))
abline(v=-1.5, lwd=1, col='red', lty=2)
```
##Barplot analysis 
```{r}
barplot(colSums(my_data) / 1e6, xlab="samples", ylab="log2(counts)", 
    main="gene counts of all patients", las=2, cex.names= 0.45)
barplot(colSums(sick_data) / 1e6, xlab="samples", ylab="log2(counts)", 
    main="gene counts of sick patients", col="red", las=2, cex.names= 0.45)
barplot(colSums(healthy_data) / 1e6, xlab="samples", ylab="log2(counts)", 
    main="gene counts of healthy patients", col="blue", las=2, cex.names= 0.45)
```
##normalisation 
```{r}
# Load the library
library('DESeq2')

# DESeq2 will construct a SummarizedExperiment object and combine this 
# into a 'DESeqDataSet' object. The 'design' argument usually indicates the 
# experimental design using the condition(s) names as a 'factor', for now we use just '~ 1'
(ddsMat <- DESeqDataSetFromMatrix(countData = my_data,
                                  colData = data.frame(samples = names(my_data)),
                                  design = ~ 1))
```

##Normalization
```{r}
# Perform normalization
rld.dds <- vst(ddsMat)
# 'Extract' normalized values
rld <- assay(rld.dds)
```

##distance calculation
```{r}
# Calculate basic distance metric (using euclidean distance, see '?dist')
sampledists <- dist( t( rld ))
```

##heatmap
```{r}
# We use the 'pheatmap' library (install with install.packages('pheatmap'))
library(pheatmap)

# Convert the 'dist' object into a matrix for creating a heatmap
sampleDistMatrix <- as.matrix(sampledists)
#The annotation is an extra layer that will be plotted above the heatmap columns
# indicating the cell type
annotation <- data.frame(Cell = factor(c(rep(1, 64), rep(2, 20)),
                                          labels = c("Sick", "Healthy")))

annotation$gender <- phenodata$characteristics_ch1.2
#Set the rownames of the annotation dataframe to the sample names (required)
rownames(annotation) <- names(my_data)

pheatmap(sampleDistMatrix, show_colnames = FALSE,
         annotation_col = annotation,
         clustering_distance_rows = sampledists,
         clustering_distance_cols = sampledists,
         show_rownames = F,
         main = "Euclidean Sample Distances")
```
##multi-dimentional scaling 
```{r}
library('PoiClaClu')
# Use the raw (not r-log transformed!) counts
dds <- assay(ddsMat)
poisd <- PoissonDistance( t(dds) )
# Extract the matrix with distances
samplePoisDistMatrix <- as.matrix(poisd$dd)
# Calculate the MDS and get the X- and Y-coordinates
mdsPoisData <- data.frame( cmdscale(samplePoisDistMatrix) )

# And set some better readable names for the columns
names(mdsPoisData) <- c('x_coord', 'y_coord')
```



```{r}
library(ggplot2)
# Separate the annotation factor (as the variable name is used as label)
groups <- factor(c(rep(1, 64), rep(2, 20)),
                                    labels = c("Sick", "Healthy"))
groups <- as.factor(paste(annotation$Cell, phenodata$characteristics_ch1.5, phenodata$characteristics_ch1.6, sep= "_"))
coldata <- names(my_data)

levels(groups)
# Create the plot using ggplot
ggplot(mdsPoisData, aes(x_coord, y_coord, color = groups, label = coldata)) + 
  geom_text(size = 4) +
  ggtitle('Multi Dimensional Scaling') +
  labs(x = "Poisson Distance", y = "Poisson Distance") +
  theme_bw()
```
There is a clear clustering of multiple samples.

## Links
https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE47944